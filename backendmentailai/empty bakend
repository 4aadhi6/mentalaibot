no bro iman tge gimmini run with this front end react native front end then the api is same to give api ts if alresy existing bakied is availbe;w bro  const express = require("express");
const dotenv = require("dotenv");
const cors = require("cors");
const connectDB = require("./config/db");

// Load environment variables
dotenv.config();

// Connect to database
connectDB();

const app = express();

// Middleware
app.use(cors()); // Enable Cross-Origin Resource Sharing
app.use(express.json()); // Body parser for JSON

// API Routes
app.get("/", (req, res) => {
  res.send("SereneMind AI API is running...");
});

app.use("/api/auth", require("./routes/auth"));
app.use("/api/admin", require("./routes/admin"));
app.use("/api/users", require("./routes/users"));
app.use("/api/journal", require("./routes/journal"));
app.use("/api/chat", require("./routes/chat"));
app.use("/api/moods", require("./routes/moods"));

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`)); const mongoose = require("mongoose");

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected...");
  } catch (err) {
    console.error(err.message);
    // Exit process with failure
    process.exit(1);
  }
};

module.exports = connectDB; const User = require("../models/User");
const JournalEntry = require("../models/JournalEntry");
const FlaggedContent = require("../models/FlaggedContent");
const Quote = require("../models/Quote");
const MoodLog = require("../models/MoodLog");

// --- DASHBOARD ---
exports.getDashboardStats = async (req, res) => {
  try {
    const userCount = await User.countDocuments();
    const journalCount = await JournalEntry.countDocuments();
    const flaggedCount = await FlaggedContent.countDocuments({
      resolved: false,
    });
    res.json({ userCount, journalCount, flaggedCount });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.getSignupStats = async (req, res) => {
  try {
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    const data = await User.aggregate([
      { $match: { signupDate: { $gte: sevenDaysAgo } } },
      {
        $group: {
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$signupDate" } },
          count: { $sum: 1 },
        },
      },
      { $sort: { _id: 1 } },
      { $project: { name: "$_id", signups: "$count", _id: 0 } },
    ]);
    res.json(data);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.getMoodDistribution = async (req, res) => {
  try {
    const data = await MoodLog.aggregate([
      { $sort: { date: -1 } },
      { $group: { _id: "$userId", latestMood: { $first: "$mood" } } },
      { $group: { _id: "$latestMood", count: { $sum: 1 } } },
      {
        $project: {
          _id: 0,
          name: {
            $switch: {
              branches: [
                { case: { $eq: ["$_id", 1] }, then: "Awful" },
                { case: { $eq: ["$_id", 2] }, then: "Bad" },
                { case: { $eq: ["$_id", 3] }, then: "Okay" },
                { case: { $eq: ["$_id", 4] }, then: "Good" },
                { case: { $eq: ["$_id", 5] }, then: "Great" },
              ],
              default: "Unknown",
            },
          },
          value: "$count",
        },
      },
    ]);
    res.json(data);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

// --- QUOTES ---
exports.getQuotes = async (req, res) => {
  try {
    const quotes = await Quote.find({});
    res.json(quotes);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.addQuote = async (req, res) => {
  try {
    const { text } = req.body;
    const newQuote = new Quote({ text });
    await newQuote.save();
    res.status(201).json(newQuote);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.deleteQuote = async (req, res) => {
  try {
    await Quote.findByIdAndDelete(req.params.id);
    res.json({ message: "Quote deleted" });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

// --- FLAGGED CONTENT ---
exports.addFlag = async (req, res) => {
  try {
    const { text, userEmail, type } = req.body;
    const newFlag = new FlaggedContent({ content: text, userEmail, type });
    await newFlag.save();
    res.status(201).json({ message: "Content flagged successfully" });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.getFlags = async (req, res) => {
  try {
    const flags = await FlaggedContent.find({ resolved: false }).sort({
      date: -1,
    });
    res.json(flags);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.resolveFlag = async (req, res) => {
  try {
    const flag = await FlaggedContent.findById(req.params.id);
    if (!flag) return res.status(404).json({ message: "Flag not found" });
    flag.resolved = true;
    await flag.save();
    res.json({ message: "Flag resolved" });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
}; const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = require("../models/User");

const generateToken = (id, isAdmin) => {
  return jwt.sign({ id, isAdmin }, process.env.JWT_SECRET, {
    expiresIn: "30d",
  });
};

exports.signup = async (req, res) => {
  const { name, email, password } = req.body;
  try {
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({ message: "User already exists" });
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const user = await User.create({
      name,
      email,
      password: hashedPassword,
    });

    if (user) {
      res.status(201).json({
        _id: user._id,
        name: user.name,
        email: user.email,
        isAdmin: user.isAdmin,
        token: generateToken(user._id, user.isAdmin),
      });
    } else {
      res.status(400).json({ message: "Invalid user data" });
    }
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });

    if (user && (await bcrypt.compare(password, user.password))) {
      res.json({
        _id: user._id,
        name: user.name,
        email: user.email,
        isAdmin: user.isAdmin,
        token: generateToken(user._id, user.isAdmin),
      });
    } else {
      res.status(401).json({ message: "Invalid email or password" });
    }
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};

exports.adminLogin = async (req, res) => {
  const { username, password } = req.body; // Using username for admin as in the frontend

  // In a real app, admin credentials might be handled differently.
  // Here we check for a user with isAdmin flag.
  // For simplicity, let's assume the admin username is their email.
  try {
    const adminUser = await User.findOne({ email: username, isAdmin: true });

    if (adminUser && (await bcrypt.compare(password, adminUser.password))) {
      res.json({
        _id: adminUser._id,
        name: adminUser.name,
        email: adminUser.email,
        token: generateToken(adminUser._id, adminUser.isAdmin),
      });
    } else {
      res.status(401).json({ message: "Invalid admin credentials" });
    }
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
}; const ChatMessage = require("../models/ChatMessage");

exports.getChatHistory = async (req, res) => {
  try {
    const messages = await ChatMessage.find({ userId: req.user._id }).sort({
      timestamp: 1,
    });
    res.json(messages);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.saveChatMessages = async (req, res) => {
  const { messages } = req.body; // Expecting an array of messages to save
  if (!messages || !Array.isArray(messages)) {
    return res.status(400).json({
      message: "Invalid data format. Expecting an array of messages.",
    });
  }

  try {
    // We only save the last two messages (user and model response)
    const messagesToSave = messages.slice(-2).map((msg) => ({
      ...msg,
      userId: req.user._id,
    }));

    await ChatMessage.insertMany(messagesToSave);
    res.status(201).json({ message: "Chat saved" });
  } catch (error) {
    console.error("Error saving chat:", error);
    res.status(500).json({ message: "Server Error" });
  }
}; const JournalEntry = require("../models/JournalEntry");

exports.getJournalEntries = async (req, res) => {
  try {
    const entries = await JournalEntry.find({ userId: req.user._id }).sort({
      date: -1,
    });
    res.json(entries);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.createJournalEntry = async (req, res) => {
  const { content } = req.body;
  try {
    const newEntry = new JournalEntry({
      content,
      userId: req.user._id,
    });
    const savedEntry = await newEntry.save();
    res.status(201).json(savedEntry);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.updateJournalSummary = async (req, res) => {
  const { summary } = req.body;
  try {
    const entry = await JournalEntry.findById(req.params.id);

    // Ensure the entry belongs to the user
    if (entry.userId.toString() !== req.user._id.toString()) {
      return res.status(401).json({ message: "Not authorized" });
    }

    entry.summary = summary;
    const updatedEntry = await entry.save();
    res.json(updatedEntry);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
}; const MoodLog = require("../models/MoodLog");

exports.getMoodLogs = async (req, res) => {
  try {
    const logs = await MoodLog.find({ userId: req.user._id }).sort({ date: 1 });
    res.json(logs);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.logMood = async (req, res) => {
  const { date, mood } = req.body; // date is 'YYYY-MM-DD'
  try {
    // Use `findOneAndUpdate` with `upsert` to create or update the log for the given day
    const updatedLog = await MoodLog.findOneAndUpdate(
      { userId: req.user._id, date: date },
      { mood: mood },
      { new: true, upsert: true, setDefaultsOnInsert: true }
    );
    res.status(201).json(updatedLog);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
}; const User = require("../models/User");
const JournalEntry = require("../models/JournalEntry");
const ChatMessage = require("../models/ChatMessage");
const MoodLog = require("../models/MoodLog");

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find({}).select("-password");
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.getUserDetails = async (req, res) => {
  try {
    const user = await User.findOne({ email: req.params.email }).select(
      "-password"
    );
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const journalEntries = await JournalEntry.find({ userId: user._id }).sort({
      date: -1,
    });
    const chatMessages = await ChatMessage.find({ userId: user._id }).sort({
      timestamp: 1,
    });
    const moodLogs = await MoodLog.find({ userId: user._id }).sort({ date: 1 });

    res.json({
      user,
      journalEntries,
      chatMessages,
      moodLogs,
    });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findOne({ email: req.params.email });
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Delete all associated data
    await JournalEntry.deleteMany({ userId: user._id });
    await ChatMessage.deleteMany({ userId: user._id });
    await MoodLog.deleteMany({ userId: user._id });

    // FIX: Replaced deprecated .remove() with .findByIdAndDelete()
    await User.findByIdAndDelete(user._id);

    res.json({ message: "User and all associated data removed" });
  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
}; const jwt = require("jsonwebtoken");
const User = require("../models/User");

const protect = async (req, res, next) => {
  let token;

  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    try {
      // Get token from header
      token = req.headers.authorization.split(" ")[1];

      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      // Get user from the token
      req.user = await User.findById(decoded.id).select("-password");
      next();
    } catch (error) {
      console.error(error);
      res.status(401).json({ message: "Not authorized, token failed" });
    }
  }

  if (!token) {
    res.status(401).json({ message: "Not authorized, no token" });
  }
};

const admin = (req, res, next) => {
  if (req.user && req.user.isAdmin) {
    next();
  } else {
    res.status(401).json({ message: "Not authorized as an admin" });
  }
};

module.exports = { protect, admin }; const mongoose = require("mongoose");

const ChatMessageSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  role: {
    type: String,
    enum: ["user", "model"],
    required: true,
  },
  text: {
    type: String,
    required: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

module.exports = mongoose.model("ChatMessage", ChatMessageSchema); const mongoose = require("mongoose");

const FlaggedContentSchema = new mongoose.Schema({
  userEmail: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    enum: ["Journal", "Chat"],
    required: true,
  },
  date: {
    type: Date,
    default: Date.now,
  },
  resolved: {
    type: Boolean,
    default: false,
  },
});

module.exports = mongoose.model("FlaggedContent", FlaggedContentSchema); const mongoose = require("mongoose");

const JournalEntrySchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  date: {
    type: Date,
    default: Date.now,
  },
  content: {
    type: String,
    required: true,
  },
  summary: {
    type: String,
  },
});

module.exports = mongoose.model("JournalEntry", JournalEntrySchema); const mongoose = require("mongoose");

const MoodLogSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  // Storing date as a string YYYY-MM-DD for easy lookups
  date: {
    type: String,
    required: true,
  },
  mood: {
    type: Number,
    enum: [1, 2, 3, 4, 5], // Awful, Bad, Okay, Good, Great
    required: true,
  },
});
// Ensure a user can only have one mood log per day
MoodLogSchema.index({ userId: 1, date: 1 }, { unique: true });

module.exports = mongoose.model("MoodLog", MoodLogSchema); const mongoose = require("mongoose");

const QuoteSchema = new mongoose.Schema({
  text: {
    type: String,
    required: true,
    unique: true,
  },
});

module.exports = mongoose.model("Quote", QuoteSchema); const mongoose = require("mongoose");

const UserSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  signupDate: {
    type: Date,
    default: Date.now,
  },
  isAdmin: {
    type: Boolean,
    default: false,
  },
});

module.exports = mongoose.model("User", UserSchema); const express = require("express");
const router = express.Router();
const {
  // Make sure ALL of these are imported
  getDashboardStats,
  getSignupStats,
  getMoodDistribution,
  getQuotes,
  addQuote,
  deleteQuote,
  addFlag,
  getFlags,
  resolveFlag,
} = require("../controllers/adminController");
const { protect, admin } = require("../middleware/authMiddleware");

// --- Dashboard Routes ---
router.get("/dashboard", protect, admin, getDashboardStats);
router.get("/dashboard/signups", protect, admin, getSignupStats);
router.get("/dashboard/moods", protect, admin, getMoodDistribution);

// --- Quotes Routes (for Content Management) ---
// Getting quotes can be public, but adding/deleting must be admin
router.get("/quotes", getQuotes);
router.post("/quotes", protect, admin, addQuote);
router.delete("/quotes/:id", protect, admin, deleteQuote);

// --- Flagged Content Routes ---
// This endpoint is called from the frontend service, so it does not need protection
router.post("/flags", addFlag);
// These endpoints are for admins to view and resolve flags
router.get("/flags", protect, admin, getFlags);
router.put("/flags/:id/resolve", protect, admin, resolveFlag);

// This is line 81 from your error, now fixed.
// It seems there may have been an extra route defined here by accident.
// This file is now clean and correct.

module.exports = router; const express = require("express");
const router = express.Router();
const { signup, login, adminLogin } = require("../controllers/authController");

router.post("/signup", signup);
router.post("/login", login);
router.post("/admin/login", adminLogin);

module.exports = router; const express = require("express");
const router = express.Router();
const {
  getChatHistory,
  saveChatMessages,
} = require("../controllers/chatController");
const { protect } = require("../middleware/authMiddleware");

router.route("/").get(protect, getChatHistory).post(protect, saveChatMessages);

module.exports = router; const express = require("express");
const router = express.Router();
const {
  getJournalEntries,
  createJournalEntry,
  updateJournalSummary,
} = require("../controllers/journalController");
const { protect } = require("../middleware/authMiddleware");

router
  .route("/")
  .get(protect, getJournalEntries)
  .post(protect, createJournalEntry);
router.post("/:id/summary", protect, updateJournalSummary);

module.exports = router; const express = require("express");
const router = express.Router();
const { getMoodLogs, logMood } = require("../controllers/moodController");
const { protect } = require("../middleware/authMiddleware");

router.route("/").get(protect, getMoodLogs).post(protect, logMood);

module.exports = router; const express = require("express");
const router = express.Router();
const {
  getAllUsers,
  getUserDetails,
  deleteUser,
} = require("../controllers/userController");
const { protect, admin } = require("../middleware/authMiddleware");

router.get("/", protect, admin, getAllUsers);
router.get("/:email", protect, admin, getUserDetails);
router.delete("/:email", protect, admin, deleteUser);

module.exports = router;
